//Code by: Andrew Hunt and Aiden Wright
//GPR-200-02
//Assignment: Lab 3
//Due Date: 24 September 2020

//Sources Used: https://raytracing.github.io/books/RayTracingInOneWeekend.html
//How it was Used: Read his rendering pipeline and built it based on principles 
//learned from him

//Sources Used: https://thebookofshaders.com/10/
//How it was Used: Used for help implementing randomness

//definitions 
#define pi 3.1415926535
#define ray vec3[2]
#define tMax 99999999.99999999f
#define tMin 0.001f

const int OBJNUM 	= 5;   	// number of objects
const int SAMPCOUT 	= 100;	// samples for antialiasing and blending
const int MAX_DEPTH = 50;	// depth for shadows and diffusion

struct sphere {
	vec3 p;	 //position of sphere friom its center point
    float r; //radius of sphere
};

struct hitRecord{
	vec3 p; 		// position of the hit
    vec3 n; 		// normalized surface
    float t; 		// distance from camera
    bool frontFace; // object is facing towards camera?
};
    
float rand(out float seed){
    //generate a random nimber between -1 and 1 based on the seed
    float random = (fract(sin(seed) * 100000.0f)-0.5f) * 2.0f; //https://thebookofshaders.com/10/
    
    //change seed
    ++seed;
    
    //return number
    return random;
}

vec3 rayLen(in float t, ray r){
	//return the length of the ray
    return r[0] + (t * r[1]);
}

vec3 atRay(in ray r, float t){
    //return the length of the ray
	return r[0] + t * r[1];
}

void setFaceNormal(out hitRecord rec, in ray r, in vec3 outward){
	rec.frontFace = dot(r[1], outward) < 0.0f;
    rec.n = rec.frontFace ? outward : (outward * -1.0f);
}

bool hitSphere(in vec3 centerPoint, in float radius, in ray r, in float cMax, in float cMin, out hitRecord rec){
    //used in calculations
    vec3 oc = r[0] - centerPoint;
    
    //calculate the normalized color float value from radius
    float a 			= dot(r[1], r[1]);
    float halfB 		= dot(oc, r[1]);
    float c 			= dot(oc, oc) - radius * radius;
    float discriminant 	= halfB * halfB - a * c;
    
   	float aInv = 1.0f / a;
    float rInv = 1.0f / radius;
    
    //return the ray length if hit
	if (discriminant > 0.0f) {
		float root = sqrt(discriminant);
        float temp = (-halfB - root) * aInv;
        
        if(temp < cMax && temp > cMin){
        	rec.t = temp;
            rec.p = atRay(r, rec.t);
            
            vec3 outwardNormal = (rec.p - centerPoint) * rInv;
            setFaceNormal(rec , r, outwardNormal);	
            return true;
        }
        
        temp = (-halfB + root) * aInv;
        if(temp < cMax && temp > cMin){
        	rec.t = temp;
            rec.p = atRay(r, rec.t);
            
            vec3 outwardNormal = (rec.p - centerPoint) * rInv;
            setFaceNormal(rec , r, outwardNormal);
            return true;
        }
    }
    

    return false;
}

bool hit(in ray r, in sphere[OBJNUM] cir, out hitRecord rec){
	hitRecord tempRec;			//hit record of each hit
    bool hitAnything = false;	//check if anything hits
    float closest = tMax;		//used to only mark the closest target hit
    
    //check each object for a hit
    for (int i = 0; i < OBJNUM; ++i) {
        if(hitSphere(cir[i].p, cir[i].r, r, closest, tMin, tempRec)){
        	//declare its hit and change hitrecord and max visible distance
            hitAnything = true;
            closest = tempRec.t;
            rec = tempRec;
        }
    }
    
    //return if anything was hit
    return hitAnything;
}

vec3 ranDir(float seed){
    //generate a radnom valid direction
    while(true){
        vec3 p = vec3(rand(seed), rand(seed), rand(seed));
        if (dot(p, p) >= 1.0f) continue;
        return p;
    }
}

vec3 rayColor(ray rayIn, sphere cir[OBJNUM], float seed, int depth){
    float ratio = 1.0f;//ratio when calculation of color

    
    while(true){
    	hitRecord rec; //temporaryt hit record
    	
        //if max depth, make shadow black
        if (depth <= 0)
            return vec3(0.0f);

        if (hit(rayIn, cir, rec)){
            //calculate diffuse based off normal    
            vec3 target = rec.p + rec.n + ranDir(seed);
			
            //bounce rays for shadows
			rayIn[0] = rec.p;
            rayIn[1] = target - rec.p;
            --depth;
            ratio *= 0.5f;
            
            //loop
            continue;
        }
        
        //calc default background by blending white and blue
        vec3 unitDir = rayIn[1] / sqrt(dot(rayIn[1], rayIn[1]));
        float t = 0.5f * (unitDir.y + 1.0f);
        return ((1.0f - t) * vec3(1.0f, 1.0f, 1.0f) + t * vec3(0.5f, 0.7f, 1.0f)) * ratio;
    }
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
    //initialize seed
    float seed = iDate.z;
    
    // -------------------------------------------------------------------
    // **Sphere Declarations**
    // -------------------------------------------------------------------
    
    //declare sphere array
    sphere obj[OBJNUM];
    
    float rate 		= 2.0f;											 // The rate and speed of the balls
    float time 		= iTime *  rate;								 // Time by rate
   		
    float horMove 	= sin(time * 0.3333f);  						 // wavy horizontal movement
    float horMoveR 	= sin(-time * 0.3333f); 						 // wavy horizontal movement reversed
    
    float ySin		= (sin(time) * sin(time) + 1.2f) * -0.5f + 1.0f; // wavy vertical movement based off sine
    float yCos		= (cos(time) * cos(time) + 1.2f) * -0.5f + 1.0f; // wavy vertical movement based off cosine
    
    //obj.p  || (vec2)  The center point of the sphere and its position
    //obj.r  || (float) The radius of the sphere
    
    //declaration of each sphere
    obj[0].p = vec3 (horMove, ySin, -10.0f - (sin(iTime * rate) * 19.3f + 0.7f) * 0.5f);
    obj[0].r = 0.5f;
    
    obj[1].p = vec3 (horMoveR, yCos, -10.0f - (cos(iTime * rate) * 19.3f + 0.7f) * 0.5f);
    obj[1].r = 0.5f;
    
    obj[2].p = vec3 (horMove * 2.0, ySin, -10.0f - (sin(iTime * rate * 0.5 + pi * 0.5) * 19.3f + 0.7f) * 0.5);
    obj[2].r = 0.5f;
    
    obj[3].p = vec3 (horMoveR * 2.0, yCos, -10.0f - (cos(iTime * rate * 0.5 + pi * 0.5) * 19.3f + 0.7f) * 0.5);
    obj[3].r = 0.5f;
    
    obj[4].p = vec3(0.0f, -100.5f, -1.0f);
    obj[4].r = 100.0f;
    
    // -------------------------------------------------------------------
    // **Camera Setup**
    // -------------------------------------------------------------------
    
    const float aspectRatio = 16.0f / 9.0f;					// aspect ratio of the project
  	
    //calculate viewports to match aspect ratio
    float viewportHeight	= 2.0f;							// height of camera
	float viewportWidth		= aspectRatio * viewportHeight; // width of camera
    float focalLength		= 1.0f;							// center point of camera

	//calculate vec3 of cameras
	vec3 origin		= vec3( 0.0f, 0.0f, 0.0f );				// origin point of camera
	vec3 horizontal = vec3( viewportWidth, 0.0f, 0.0f );	// furthest right point of camera
	vec3 vertical	= vec3( 0.0f, viewportHeight, 0.0f );	// furthest top point of camera

	//calculate lower left corner
	vec3 lowerLeftCorner = origin - (horizontal * 0.5f) - (vertical * 0.5f) - vec3(0.0f, 0.0f, focalLength);
	
    // -------------------------------------------------------------------
    // **Rendering Per Pixel**
    // -------------------------------------------------------------------
    
    //calculate verticle and horizontal position of a targetted pixel
    vec2 invRes = 1.0/iResolution.xy;
    vec2 uv = fragCoord * invRes;
    
    //get color of the pixel by calculation of cricle
    vec3 pixelcColor = vec3(0.0f);
	
    //smaple calcs
    float sampF = float(SAMPCOUT);
    
    //take multiple samples and average them together
    for (int i = 0; i < SAMPCOUT; ++i){
        //calc position of sub pixel
        vec2 samplePoint = uv;
        samplePoint.x += invRes.x * rand(seed);
        samplePoint.y += invRes.y * rand(seed);
        
        //declare and assign ray per pixel
    	ray pixleRay;
    	pixleRay[0] = origin;
    	pixleRay[1] = lowerLeftCorner + horizontal * samplePoint.x 
            		  + samplePoint.y * vertical - origin;
        
        //calc subpixel color
    	pixelcColor += rayColor(pixleRay, obj, seed, MAX_DEPTH);
    }
    
    //raise gamma and blend sub pixels
    pixelcColor = sqrt(pixelcColor / sampF);
    
    //output pixel
    fragColor = vec4(pixelcColor, 1.0f);
}
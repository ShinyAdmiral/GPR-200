#define pi 3.1415926535

//effect 0
vec4 colorGrad(in vec2 coords, in  vec2 res){
    //make pixels a certain color depending on thier screen location
    vec2 uv = coords / res.xy;
    return vec4(uv, 0.0f, 1.0);
}

//effect 1
vec4 checkeroard (in vec2 coords, in vec2 res){
    //tile the screen based on aspect ratio (normalizes tiles)
	vec2 tileSize;
    tileSize.x = res.x/32.0f;
    tileSize.y = res.y/18.0f;
    
    //These variables are getting the cordinates of each tile 
    int coordCheckX = int(floor(coords.x / tileSize.x)) + 1;
    int coordCheckY = int(floor(coords.y / tileSize.y)) + 1;
    
    //for every odd row, white is on the odd colums and black is on the even
    vec4 checkerColor;
    if (coordCheckY % 2 > 0){
        if (coordCheckX % 2 > 0) checkerColor = vec4(0,0,0,1);
        else 					 checkerColor = vec4(1);
    }
    
    //for every even row, white is on the even colums and black is on the odd
    else{
    	if (coordCheckX % 2 > 0) checkerColor = vec4(1);
        else 					 checkerColor = vec4(0,0,0,1);
    }
	
    //return fragment color
    return checkerColor;
}

// effect 2
//reference: jonobr1 https://www.shadertoy.com/user/jonobr1
vec4 growCircle(in vec2 coord, in vec2 res, float theTime){
    //normalize coords and get center of screen
    vec2 uv = coord/res.xy;
	vec2 center = res.xy * 0.5f;
    
    //set some variables to change the circle
    float time = 1.5f;
    float growth = 3.0f;
    float minRadius = 0.5f;
    
    //calculate radius growth
    float radius = (res.y * 0.25f);
    float radExt = abs(mod(theTime * time, growth) - mod(theTime * time * 0.5f,growth)) + minRadius;
    radius *= radExt;
    
    //Background layer
    vec3 backCol = 0.5f + 0.5f*cos(theTime+uv.xyx+vec3(4.0f,2.0f,6.0f));
    vec4 layer1 = vec4(backCol, 1.0f); 
    
    //draw the circle on layer 2   
    vec3 color = vec3(abs(backCol.x - 1.0f), abs(backCol.y - 1.0f), abs(backCol.z - 1.0f));
	float d = length(center - coord) - radius;	//credit jonobr1
    float t = clamp(d, 0.0f, 1.0f);				//credit jonobr1
    vec4 layer2 = vec4(color, 1.0f - t);		//credit jonobr1
    
    // Output to screen (interpolate between both layers)
    return mix(layer1, layer2, layer2.a);

}

//effect 3
float Circle (vec2 uv, vec2 pos, float radius, float blur){
    //calculate circle and smooth it out 
    float d = length(uv-pos);
    float color = smoothstep(radius, radius - blur, d);
    return color;
}

float rad(float degree){
    //convert degrees to radians
	return (pi * degree)/180.0f;
}

vec4 psychedelic(vec2 coord, float currentTime, vec2 res){
    //normalize pixels, center it, then prevent stretch
    vec2 uv = coord/res.xy;
    uv -= 0.5;
    uv.x *= res.x/res.y;
    
    float time = currentTime * 0.75f; 
    
    float color;	// sigular channel for a color
    float dist;		// distance from center
    float radius;	// radius of the circle
    float distX;	// x position of circles
    float distY;	// y position of circles
    float angleSize;// how far spread apart the circles are
    float speed;	// speed  of the 
    
    //layer 1
    dist = mod(time, 2.0f);
    radius = mod(time * 0.1f, 0.2f);
    angleSize = 15.0f;
    speed = 0.5f;
    distX = sin(rad(time)) * dist;
    distY = cos(rad(time)) * dist;
    color = Circle(uv, vec2(distX, distY), radius, 0.01f);
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle) + time * speed) * dist;
        distY = cos(rad(angle) + time * speed) * dist;
        color += Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 2
    dist = mod(time * 0.5, 2.0f);
    radius = mod(time * 0.1f, 0.2f);
    speed = 1.5f;
    angleSize = 15.0f;
    
    distX = sin(rad(0.0f)) * dist;
    distY = cos(rad(0.0f)) * dist;
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color += Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 3
    dist = mod(time * 0.25, 2.0f);
    radius = mod(time * 0.1f, 0.2f);
    speed = 1.5f;
    angleSize = 15.0f;
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i+ mod(time * 2.0f, angleSize);
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color += Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 4
    dist = mod(time, 1.0f) + 0.2;
    radius = mod(time * 0.1f, 0.2f);
    speed = 2.5f;
    angleSize = 15.0f;
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color += Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 5
    dist = mod(time, 1.0f);
    radius = mod(time * 0.03f, 0.06f);
    speed = 1.0f;
    angleSize = 7.5f;
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color -= Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 6
    dist = mod(time * 0.9f, 2.0f);
    radius = mod(time * 0.1f, 0.2f);
    speed = 0.5f;
    angleSize = 15.0f;
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color -= Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
    
    //layer 7
    dist = mod(time * 0.25, 2.0f);
    radius = mod(time * 0.1f, 0.2f);
    speed = 1.0f;
    angleSize = 15.0f;
    
    for (float i = 0.0f; i < 360.0f/angleSize; i++){
        float angle = angleSize * i;
        
        distX = sin(rad(angle)+ (time * speed)) * dist;
        distY = cos(rad(angle)+ (time * speed)) * dist;
        color -= Circle(uv, vec2(distX, distY), radius, 0.01f);
    }
  
    // Output to screen
    if (color == 0.0f){
        vec3 v = 0.3f + 0.2f*cos(currentTime+uv.xyx+vec3(1.0,4.0f,2.0));
    	return vec4(v,1.0f);
    }
    else{
    	return vec4(vec3(color, abs(mod(currentTime * 0.25, 1.0) - 1.0), 0.5f),1.0f);
    }
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
    //effect 0 (Static Color RG)
    //fragColor = colorGrad(fragCoord, iResolution.xy);
    
    //effect 1 (Checkeroard)
    //fragColor = checkeroard(fragCoord, iResolution.xy);
    
    //effect 2 (Growing Circle)
    //fragColor = growCircle(fragCoord, iResolution.xy, iTime);
    
    //effect 3 (Psychedelic Effect)
    fragColor = psychedelic(fragCoord, iTime, iResolution.xy);
}
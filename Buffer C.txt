// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info

const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 1000.0;
const float EPSILON = 0.00001;
const float SENSITIVITY = 0.1;

float sceneInfinite(vec3 eyePos, float time)
{
 	float modulo = 2.0;
    float halfMod = 1.0;
    
    vec3 modeye = mod(eyePos, modulo) - vec3(halfMod);
    
    float time1 = sin(time * 0.5) * 0.5 + 0.5;
    float time2 = cos(time * 0.5) * 0.5 + 0.5;
    
    
    float sphere 		= sphereSDF(modeye, 0.65 * time1);
    float cube 			= sdBox(modeye, vec3(0.5) * time1); 
    float intersect1	= intersectSDF(cube, sphere);
    
    sphere 				= sphereSDF(modeye, 0.6 * time1);
    float difference1	= differenceSDF(intersect1, sphere);
    
    float rotateTime 	= time * 0.25;
    vec4 octPos			= vec4(modeye, 0.0)
        				  * rotateY(sin(rotateTime)) * rotateX(cos(rotateTime)) * rotateZ(sin(rotateTime));
    
    float octahedron	= sdoctahedron(octPos.xyz, 0.4 * (time2 + 0.75));
    
    vec3 sphereoff		= modeye;
    sphereoff.y 		= mod(eyePos.y, 0.5) - 0.25;
    sphere 				= sphereSDF(sphereoff, 0.2 * time2);
    float union1 		= unionSDF(octahedron, sphere);
    
    sphereoff			= modeye;
    sphereoff.z 		= mod(eyePos.z, 0.5) - 0.25;
    sphere 				= sphereSDF(sphereoff, 0.2 * time2);
    float union2 		= unionSDF(union1, sphere);
    
    sphereoff			= modeye;
    sphereoff.x 		= mod(eyePos.x, 0.5) - 0.25;
    sphere 				= sphereSDF(sphereoff, 0.2 * time2);
    float union3 		= unionSDF(union2, sphere);
    
    float subResult		= unionSDF(difference1, union3);
    
    return subResult;   
}

float sceneMandel(vec3 eyePos)
{
	float scale = .1;
  	float mb = mandelbulb(eyePos * scale, iTime) / scale;
    return mb;           
}


float sceneSDF(vec3 eyePos, float time)
{	            
    //return sceneMandel(eyePos);
    return sceneInfinite(eyePos, time);         
}

// Uses the estimated gradient to find the normal at a point (similar to rise over run)
vec3 estimateNormal(vec3 p) 
{
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}


float calcColor(vec3 eyePos, vec3 marchDirection, float start, float end)
{
    float depth = start;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) 
    {        
    	float dist = sceneSDF(eyePos + depth * marchDirection);
    	if (dist < EPSILON) 
        {        	
        	return depth;// We're inside the scene surface!
    	}    
    	depth += dist; // Move along the view ray
        if (depth >= end) 
        {        
        	return end; // Gone too far; give up
	    }
	}
	return end;
}

color4 shading(in sViewport vp, sBasis surfacePosition)
{    
    
    FPointLight pLight;
    
    initPointLight(pLight, 
                   vec3(0.,200., 3.),
                   vec3(1.),
                   100000.);

    
    sBasis surfaceNormal = estimateNormal(surfacePosition);
    float phong = phongReflectance(surfacePosition, surfaceNormal, pLight, vp.viewportPoint.xyz);
    float lambert = diffuseIntensity(surfacePosition, surfaceNormal, pLight.center, pLight.intensity); // diffuse intensity
    
    color4 cL = color4(1.);
    color4 cD = color4(1.,0.,0.,0.);
    sScalar iD = lambert;
    sScalar iS = phong;
    iS *= iS;
    iS *= iS;
    iS *= iS;    
    color4 cS = vec4(1.);
    
    //add 0.03 for ambience
    return (iS * cS) + (cD * iD) * vec4(pLight.color,1.) + 0.2;	
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //get normalized coords
    sCoord uv = fragCoord / iResolution.xy;
    
    // viewing plane (viewport) inputs    
    const sScalar viewportHeight = 2.0, focalLength	 = 1.5;        
    sViewport vp;	    
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);    
        
    vec3 movement = texture(iChannel0, uv).xyz * SENSITIVITY;
    //movement.xyz *= rotate(texture(iChannel1,uv).xy);  
    
    vec3 eye = vec3(0.,1.,10.) + movement;
    vp.viewportPoint = vec4(eye,0.);
	vec3 dir = rayDirection(45., iResolution.xy, fragCoord) * rotate(texture(iChannel1,uv).xy);        
    
    float dist = calcColor(eye, dir, MIN_DIST, MAX_DIST);
    
    if(dist > MAX_DIST - EPSILON)
    {
        fragColor = vec4(0) * 10.; 
        return;
    }       
    sBasis surfacePosition = vec3(eye + dist * dir);
    
    fragColor = shading(vp, surfacePosition);
}

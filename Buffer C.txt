// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info

const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.0001;


float sceneSDF(vec3 eyePos)
{
    return min(sphereSDF(eyePos, 1.), sphereSDF(eyePos - vec3(3.,0,-10.), 1.));
}

// Uses the estimated gradient to find the normal at a point (similar to rise over run)
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}


float calcColor(vec3 eyePos, vec3 marchDirection, float start, float end)
{
    float depth = start;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) 
    {        
    	float dist = sceneSDF(eyePos + depth * marchDirection);
    	if (dist < EPSILON) 
        {        	
        	return depth;// We're inside the scene surface!
    	}    
    	depth += dist; // Move along the view ray
        if (depth >= end) 
        {        
        	return end; // Gone too far; give up
	    }
	}
	return end;
}

color4 shading(in sViewport vp, sBasis surfacePosition)
{    
    
    FPointLight pLight;
    
    initPointLight(pLight, 
                   vec3(sin(iTime) * 3.,cos(iTime) * 3., 3.),
                   vec3(1.),
                   20.);

    
    sBasis surfaceNormal = estimateNormal(surfacePosition);
    float phong = phongReflectance(surfacePosition, surfaceNormal, pLight, vp.viewportPoint.xyz);
    float lambert = diffuseIntensity(surfacePosition, surfaceNormal, pLight.center, pLight.intensity); // diffuse intensity
    
    color4 cL = color4(1.);
    color4 cD = color4(1.);
    sScalar iD = lambert;
    sScalar iS = phong;
    iS *= iS;
    iS *= iS;
    iS *= iS;    
    color4 cS = vec4(1.);
    return (iS * cS) + (cD * iD) * vec4(pLight.color,1.);	
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //get normalized coords
    sCoord uv = fragCoord / iResolution.xy;
    
    // viewing plane (viewport) iinputs    
    const sScalar viewportHeight = 2.0, focalLength	 = 1.5;        
    sViewport vp;	    
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);    
        
    vec3 eye = vec3(0.,1.,10.);
    vp.viewportPoint = vec4(eye,0.);
	vec3 dir = rayDirection(45., iResolution.xy, fragCoord);        
    
    float dist = calcColor(eye, dir, MIN_DIST, MAX_DIST);
    if(dist > MAX_DIST - EPSILON)
    {
        fragColor = vec4(0.); 
        return;
    }       
    sBasis surfacePosition = vec3(eye + dist * dir);
    
    fragColor = shading(vp, surfacePosition);
}

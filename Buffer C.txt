// Referenced: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/
// Code by Rhys Sullivan and Andrew Hunt
const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
#define mand
#ifdef mand
#define COL vec4(abs(sin(iTime * speed)), abs(cos(iTime * speed)), 0.,0.)
const float EPSILON = .01;
#else
#define COL vec4(1.)
const float EPSILON = .0001;
#endif
const float SENSITIVITY = 0.1;

float sceneInfinite(vec3 eyePos, float time)
{
    float modulo = 2.0;
    float halfMod = 1.0;
    
    vec3 modeye = mod(eyePos, modulo) - vec3(halfMod);
    
    float time1 = sin(time * 0.5) * 0.5 + 0.5;
    float time2 = cos(time * 0.5) * 0.5 + 0.5;
    
    
    float sphere         = sphereSDF(modeye, 0.65 * time1);
    float cube             = sdBox(modeye, vec3(0.5) * time1); 
    float intersect1    = intersectSDF(cube, sphere);
    
    sphere                 = sphereSDF(modeye, 0.6 * time1);
    float difference1    = differenceSDF(intersect1, sphere);
    
    float rotateTime     = time * 0.25;
    vec4 octPos            = vec4(modeye, 0.0)
                          * rotateY(sin(rotateTime)) * rotateX(cos(rotateTime)) * rotateZ(sin(rotateTime));
    
    float octahedron    = sdoctahedron(octPos.xyz, 0.4 * (time2 + 0.75));
    
    vec3 sphereoff        = modeye;
    sphereoff.y         = mod(eyePos.y, 0.5) - 0.25;
    sphere                 = sphereSDF(sphereoff, 0.2 * time2);
    float union1         = unionSDF(octahedron, sphere);
    
    sphereoff            = modeye;
    sphereoff.z         = mod(eyePos.z, 0.5) - 0.25;
    sphere                 = sphereSDF(sphereoff, 0.2 * time2);
    float union2         = unionSDF(union1, sphere);
    
    sphereoff            = modeye;
    sphereoff.x         = mod(eyePos.x, 0.5) - 0.25;
    sphere                 = sphereSDF(sphereoff, 0.2 * time2);
    float union3         = unionSDF(union2, sphere);
    
    float subResult        = unionSDF(difference1, union3);
    
    return subResult;   
}

float sceneMandel(vec3 eyePos)
{
	float scale = .1;
  	float mb = mandelbulb(eyePos * scale, iTime) / scale;
    return mb;           
}

float sceneDemo(vec3 eyePos)
{
 return sphereSDF(eyePos, 1.);   
}

float sceneSDF(vec3 eyePos)
{	
   // return sceneDemo(eyePos);
    #ifdef mand
    return sceneMandel(eyePos);
    #else
    return sceneInfinite(eyePos, iTime);         
    #endif
}

// Uses the estimated gradient to find the normal at a point (similar to rise over run)
vec3 estimateNormal(vec3 p) 
{    
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

vec4 shading(vec3 surfacePosition, vec3 eye)
{        
    FPointLight pLight;    
    initPointLight(pLight, 
                   vec3(3000.,1000., 3000.),
                   vec3(1.),
                   10000.);
    float speed = .5;        
    vec3 surfaceNormal = estimateNormal(surfacePosition); 
    float phong = phongReflectance(surfacePosition, surfaceNormal, pLight, eye);
    float lambert = diffuseIntensity(surfacePosition, surfaceNormal, pLight.center, pLight.intensity); // diffuse intensity    
    vec4 cL = vec4(1.); // color light
    vec4 cD = COL; // color of surface
    float iD = lambert; // lambert shading
    float iS = phong; // phong shading    
    iS *= iS; // scale phong
    iS *= iS;
    iS *= iS;    
    vec4 cS = vec4(1.); // specular color        
    return (iS * cS) + (cD * iD) * vec4(pLight.color,1.) + 0.03; // final color equation
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{            
    // Camera Setup
    vec3 camStart = vec3(0.,1.,40.);
    vec2 uv = fragCoord / iResolution.xy;	//get normalized coords
    vec3 movement = texture(iChannel0, uv).xyz * SENSITIVITY; // read the current cam pos
    vec3 eye = camStart + movement; // starting eye position + movement delta
	vec3 dir = rayDirection(90., iResolution.xy, fragCoord) * rotate(texture(iChannel1,uv).xy); // direction
    
    // Ray March into Scene to find Objects
    float dist; // store distance value   
    float depth = MIN_DIST;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) 
    {        
    	dist = sceneSDF(eye + depth * dir); // get dist to scene
    	if (dist < EPSILON) // early exit if we are in the object
        {        	
        	dist = depth;
            break;
    	}    
    	depth += dist; 
        if (depth >= MAX_DIST) // exit if we have overshot the max distance
        {        
        	dist = MAX_DIST;
            break;
	    }
	}	            
    if(dist > MAX_DIST - EPSILON)
    {
        fragColor = texture(iChannel2, -dir); // texture the background based on a cube map
        return;
    }       
    vec3 surfacePosition = vec3(eye + dist * dir); // get where we hit the scene    
    fragColor = shading(surfacePosition, eye); // shade where we hit
}

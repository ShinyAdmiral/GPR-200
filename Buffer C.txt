// calcColor: calculate the color of current pixel
//	  vp:  input viewport info
//	  ray: input ray info

const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 1000.0;
const float EPSILON = 0.0001;
const float SENSITIVITY = 0.1;

float sceneSDF(vec3 eyePos)
{	
    if(eyePos.x > .2)
    {
        vec4 bPos = (vec4(mod(eyePos,3.), 1.) - vec4(1.5,1.5,1.5,0.)) * rotateY(sin(iTime));
    	return sdBox(bPos.xyz, vec3(.2));    
    }
    else
    {
		vec4 bPos = (vec4(mod(eyePos,3.), 1.) - vec4(1.5,1.5,1.5,0.)) * rotateY(sin(iTime));
    	return sphereSDF(bPos.xyz, 0.75);    
    }
    
    
    
    
    float sphereDist = sphereSDF(eyePos/1.2, 3.3);
    vec4 cubePos = vec4(eyePos,0.) * rotateY(sin(iTime));
    float cubeDist = sdBox(cubePos.xyz, vec3(3.));
	return differenceSDF(cubeDist, sphereDist);
    return sphereSDF(mod(eyePos, 3.0) - vec3(1.5), 0.75);    
    return sdBox(mod(eyePos, 3.0) - vec3(1.5), vec3(.2));    
    
}

// Uses the estimated gradient to find the normal at a point (similar to rise over run)
vec3 estimateNormal(vec3 p) 
{
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}


float calcColor(vec3 eyePos, vec3 marchDirection, float start, float end)
{
    float depth = start;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) 
    {        
    	float dist = sceneSDF(eyePos + depth * marchDirection);
    	if (dist < EPSILON) 
        {        	
        	return depth;// We're inside the scene surface!
    	}    
    	depth += dist; // Move along the view ray
        if (depth >= end) 
        {        
        	return end; // Gone too far; give up
	    }
	}
	return end;
}

color4 shading(in sViewport vp, sBasis surfacePosition)
{    
    
    FPointLight pLight;
    
    initPointLight(pLight, 
                   vec3(sin(iTime) * 3.,20., 3.),
                   vec3(1.),
                   20000.);

    
    sBasis surfaceNormal = estimateNormal(surfacePosition);
    float phong = phongReflectance(surfacePosition, surfaceNormal, pLight, vp.viewportPoint.xyz);
    float lambert = diffuseIntensity(surfacePosition, surfaceNormal, pLight.center, pLight.intensity); // diffuse intensity
    
    color4 cL = color4(1.);
    color4 cD = color4(1.);
    sScalar iD = lambert;
    sScalar iS = phong;
    iS *= iS;
    iS *= iS;
    iS *= iS;    
    color4 cS = vec4(1.);
    
    //add 0.03 for ambience
    return (iS * cS) + (cD * iD) * vec4(pLight.color,1.) + 0.2;	
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //get normalized coords
    sCoord uv = fragCoord / iResolution.xy;
    
    // viewing plane (viewport) inputs    
    const sScalar viewportHeight = 2.0, focalLength	 = 1.5;        
    sViewport vp;	    
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);    
        
    vec3 movement = texture(iChannel0, uv).xyz * SENSITIVITY;
    movement.xyz *= rotate(texture(iChannel1,uv).xy);    
    vec3 eye = vec3(0.,1.,10.) + movement;
    vp.viewportPoint = vec4(eye,0.);
	vec3 dir = rayDirection(45., iResolution.xy, fragCoord) * rotate(texture(iChannel1,uv).xy);        
    
    float dist = calcColor(eye, dir, MIN_DIST, MAX_DIST);
    if(dist > MAX_DIST - EPSILON)
    {
        fragColor = vec4(0.,.2,8.,0.) * 10.; 
        return;
    }       
    sBasis surfacePosition = vec3(eye + dist * dir);
    
    fragColor = shading(vp, surfacePosition);
}
